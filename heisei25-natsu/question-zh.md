# 2013 创情夏入试

## 编程

### 表1：L 的指令

| 指令 | 说明 |
| ----------- | ----------------------------------------------------------------------------|
| ADD &emsp; $α$&emsp;$β$     | 将 $α$ 加到 $β$ 上。$β$ 的新值为 $α + β$。$β$ 必须是变量名。     |
| CMP &emsp; $α$&emsp;$β$     | 若 $α$ 等于 $β$，跳过下一条指令；否则执行下一条指令。              |
| JMP &emsp; $α$&emsp;$β$     | 跳转到当前指令下方 $α$ 行处（若 $α$ 为负整数则向上跳转）。$β$ 不使用。|
| PRN &emsp; $α$&emsp;$β$     | 打印 $α$ 和 $β$，随后终止执行。                                 |
| SET &emsp; $α$&emsp;$β$     | 将变量 $α$ 设为 $β$ 的值。$α$ 必须是变量名。                     |

$α$ 和 $β$ 要么是整数常量，要么是变量名。

(1) USB 闪存中包含 `prog1.txt`，它是一段用 L 编写的代码。请编写程序读取该 L 代码并打印每一行的第一个操作数。举例而言，如果某一行是：

```
SET x 1
```

那么第一个操作数是 x，第二个是 1，因此需要打印 x。

(2) 说明下述 L 代码的行为：

```
SET x 1
SET y 0
ADD x y
ADD 1 x
CMP x 10
JMP -3 0
PRN x y
```

(3) 编写一个程序，读取 L 代码并执行它。请用 USB 闪存中的 `prog2.txt` 对你的程序进行测试。你可以不实现 `prog2.txt` 未使用的 CMP 和 JMP 指令。可假设交给程序的 L 代码合法且行数少于 100 行。

(4) 在 (3) 的程序基础上扩展，支持表1中的全部指令。请将由 a 到 z 组成的任意单词都视为 L 中可用的变量，例如 `i` 或 `count`。使用 USB 闪存中的 `prog3.txt` 对程序进行测试。

(5) 在 (4) 的程序基础上扩展，支持表2中的新指令 SUB（调用子程序）和 BAK（返回）。允许嵌套的子程序调用。使用 USB 闪存中的 `prog4.txt` 进行测试。

(6) 在 (5) 的程序基础上扩展，支持表3中的新指令 CAL（调用）和 RET（返回），用于实现函数调用。使用 USB 闪存中的 `prog5.txt` 进行测试。注意，从 CAL 到 RET 之间的变量必须视为局部变量。指令需要支持递归函数调用。函数实参可通过特殊变量 `in` 在执行 RET 前访问，而上一次函数调用的返回值可通过特殊变量 `out` 获取。

### 表2：SUB 与 BAK

| 指令 | 说明 |
| ----------- |----------------------------------------------------------------------------------------------------------------- |
| SUB  $α$&emsp;$β$     | 记录返回位置并跳转到当前指令下方 $α$ 行处（若 $α$ 为负整数则向上跳转）。$β$ 不使用。   |
| BAK $α$&emsp;$β$     | 返回到 SUB 所记录的位置。$α$ 和 $β$ 不使用。|

$α$ 和 $β$ 要么是整数常量，要么是变量名。

### 表3：CAL 与 RET

| 指令 | 说明 |
| ----------- | ---------------------------------------------------- |
| CAL $α$&emsp;$β$     | 记录返回位置并跳转到当前指令下方 $α$ 行处（若 $α$ 为负整数则向上跳转）。$β$ 是实参。 |
| RET $α$&emsp;$β$     | 返回到 CAL 所记录的位置。$α$ 是返回值，$β$ 不使用。                                                                       |

$α$ 和 $β$ 要么是整数常量，要么是变量名。
